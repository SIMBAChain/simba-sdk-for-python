{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ensure SDK for Python","text":"<p>The Python Ensure SDK simplifies creating, managing, and using Ensure features from Python code. This is including but not limited to: Creating Decentralised Identity Documents (DIDs), Verifiable Credentials (VPs), and Verifiable Presentations (VPs).</p>","tags":["developer tools"]},{"location":"#essential-overview","title":"Essential Overview","text":"<ul> <li>The Ensure SDK is how you should communicate with Ensure services wherever you run Python code.</li> <li>The minimum supported Python version is 3.8 or later.</li> <li>You must have been onboarded to a SIMBA environment that has Ensure available to use the SDKs</li> <li>The SDK and API is still in development. Whilst we strive for stability, please be aware that functions may change with short notice. All public-facing breaking changes will be communicated with advance notice.</li> </ul>","tags":["developer tools"]},{"location":"#non-essential-details","title":"Non-essential Details","text":"<ul> <li>The SDK is automatically generated from the OpenAPI definitions published by the services that comprise the Ensure product.</li> </ul>","tags":["developer tools"]},{"location":"#getting-started","title":"Getting Started","text":"<p>Install the latest version of the SDK via pip: <pre><code>pip install simba-sdk\n</code></pre></p> <p>The <code>simba-sdk</code> needs a configuration set up before it can be used. This is done using environment variables, so depending on your situation, you may hard-code values using <code>os.environ[...]</code>, use a <code>.env</code> file, or just set environment variables at runtime.</p> <p>The required set of environment variables are as follows: - <code>CLIENT_ID</code> - <code>CLIENT_SECRET</code> - <code>TOKEN_URL</code> - <code>CREDENTIAL_URL</code> - <code>RESOURCE_URL</code> - <code>MEMBERS_URL</code></p>","tags":["developer tools"]},{"location":"#check-your-details","title":"Check your details","text":"<p>Now validate your generated authentication credentials against the Ensure service. This section assumes that you have the <code>dotenv</code> library installed, and have the required config in a <code>.env</code> file.</p> <p>Here's an example of a <code>.env</code> file below. The client ID and client secret can be obtained from the members service. You will need User Impersonating Client Credentials in order to authorise the SDK to make requests on your behalf.</p> <pre><code>CLIENT_ID=...\nCLIENT_SECRET=...\nMEMBERS_URL=https://simba-dev-members-service.platform.simbachain.com\nCREDENTIAL_URL=https://simba-dev-credential-service.platform.simbachain.com\nRESOURCE_URL=https://simba-dev-resource-service.platform.simbachain.com\nTOKEN_URL=https://simba-dev-members-service-validator.platform.simbachain.com/oauth/token\nENVIRONMENT=dev\n</code></pre> <p>Write the following code either in a script or an interactive python shell that has the Ensure SDK installed:</p> <pre><code>from dotenv import load_dotenv\nimport asyncio\n\n# load environment variables from a .env file if they are not being set in the shell\nload_dotenv(\"/path/to/config/.env\")\n\nfrom simba_sdk import EnsureClient\n\nDOMAIN = \"my_domain\"\n# initialise a new client\n# your auth credentials will be picked up by the settings object under the hood\nclient = EnsureClient()\n\n# The client has a few helper properties that get set the first time you authorise.\n# You can authorise manually\nawait client.authorise()\n\n# or call any of the endpoints to do so automatically.\nawait client.set_domain(DOMAIN)\n\n# any problems with authorisation will raise an exception, but just to double-check nothing's failing silently,\n# we can now check our user profile from within the client.\nprint(client.user)\n</code></pre> <p>The result should be a schema containing your profile, id, email etc. The information is obtained from the member service so it should be identical to a payload you get from the member service directly.</p>","tags":["developer tools"]},{"location":"#troubleshooting","title":"Troubleshooting","text":"<p>The ensure client uses a simple exception structure that wraps around the request exceptions raised by the service clients. This means that there should be some plain description as to what's gone wrong, but also the response itself from the API if you need to do any further digging.</p>","tags":["developer tools"]},{"location":"usage/","title":"SDK usage patterns","text":"<p>Almost every use case for the Ensure client starts with you setting your domain (which authorises for you under the hood!). You need to make transactions on the blockchain in a lot of scenarios, so you'll also need to set an account <pre><code>    from simba_sdk import EnsureClient\n    from simba_sdk.ensure.client import credential_schemas as cs\n\n    DOMAIN, BLOCKCHAIN = \"my-domain\", \"my-blockchain\"\n\n    async def setup() -&gt; EnsureClient:\n        client = EnsureClient()\n        await client.set_domain(DOMAIN)\n        default_account = await client.create_custodial_account(\n            cs.CreateAccountHttp(nickname=\"my-test-account\", domain=DOMAIN))\n        ACCOUNT = default_account.alias\n        await client.set_account(network=BLOCKCHAIN, alias=ACCOUNT)\n        print(f\"Performing actions as {client.user}, in {client.domain}, with account {client.account}\")\n        return client\n\n    authenticated_client = await setup()\n</code></pre></p>"},{"location":"usage/#create-a-did","title":"Create a DID","text":"<p>Decentralised Identifiers (DIDs) are an on chain way of representing a single entity (user, organisation etc.). A HOLDER DID can hold various credentials, which are issued to it by an ISSUER DID. <pre><code>import uuid\nimport asyncio\nfrom simba_sdk import EnsureClient\nfrom simba_sdk.ensure.client import credential_schemas as cs\n\nclient: EnsureClient = ...  # assuming common setup from above\ntrust_profiles_response = await client.list_trust_profiles()\ntrust_profile = trust_profiles_response.items[0]\n\nnew_issuer_did = cs.CreateDidHttp(\n  trust_profile=f\"{trust_profile.name}\",\n  account=cs.PubKeyAccountInfo(\n      public_key=client.account.public_key,\n      alias=client.account.alias\n  ),\n  permission=cs.DidPermission.ISSUER,\n  alias=\"my_test_dids\",\n  nickname=\"My new Issuer DID\",\n  public_name=cs.PublicName(f\"{client.user.profile.first_name}'s ISSUER DID\"),\n  seed = str(uuid.uuid4())\n)\n\ntask_id = await(client.create_did(createdidhttp=new_issuer_did))\n\n# This creates a task to publish the DID, you might need to wait a sec for it to show up\n# Or automatically wait until the task is complete\nwhile True:\n  task: cs.Task = await(client.credential_get_task(task_id))\n  if task.status == cs.TaskStatus.COMPLETED:\n    break\n\n# We can double-check as well\ndid: cs.DIDResponseModel = await client.get_did(did_id=task.object_id)\nprint(did)\n</code></pre></p> <p>N.B. The process is near identical for HOLDER dids, just change 'ISSUER' to 'HOLDER' in the input payload.</p>"},{"location":"usage/#issue-a-vc","title":"Issue a VC","text":"<p>One DID can issue a Verifiable Credential(VC) to another DID. This is essentially the issuer making a claim about the holder, i.e. that they hold a Bachelors Degree from the Issuer's University. VCs follow a pattern known as a schema, this defines what attributes the claim is actually attributing to the Holder. <pre><code>from datetime import datetime, timedelta\nfrom simba_sdk.ensure.client import credential_queries as cq\nmy_schemas =  await client.get_schema_registry()\nmy_schema = list(my_schemas.schemas.values())[0]\n\n# vc\nmy_new_vc = credential_schemas.CreateVCHttp(\n  issuer=issuer_did.did_document[\"id\"],\n  subject=holder_did.did_document[\"id\"],\n  valid_from=datetime.now() - timedelta(days=1), # yesterday\n  valid_until=datetime.now() + timedelta(days=365), # this time next year\n  material={\"circom_circuit\": \"SMTInclusionSingleClaim\"}, # this is how the claims will be verified against the holder on chain\n  claims={\n      my_schema.id[:my_schema.id.find(\"#\")]: { # the schema comes back in the form link#schema_name. We just need the link here\n      my_schema.name:{ # this is schema_name\n              my_schema.attributes[0].name: my_schema.attributes[0].suggestedValues[0], # a reliable way to make a verifiable claim. realistically you would input whatever value you actually need here.\n          }\n      }\n  },\n  tags=[\"sdk\", \"test\", \"ensure\"]\n)\n\n# assuming this is an asynchronous function, we can use await instead of asyncio.run()\nvc_id = await client.create_vc(createvchttp=my_new_vc)\n\nvc = await client.get_vc(vc_id=vc_id)\n\n# Verify the VC\nresult = await client.verify_vc(body=vc.model_dump_json())\nif not result.success:\n  raise Exception(\"The VC is invalid for some reason.\")\n\nawait client.accept_vc(vc_id=vc_id,query_arguments=cq.AcceptVcQuery(accept=True)) # the Holder needs to accept the credentials\n</code></pre></p>"},{"location":"usage/#create-a-vp","title":"Create a VP","text":"<p>A Verifiable Presentation (VP) is a secure presentation of a VC. It allows entities to verify an entity holds a VC without exposing knowledge about the entity or the VC.</p> <pre><code>import json\n\nADDRESS_FOR_YOUR_CREDENTIAL_DOMAIN = trust_profile.config.registrar_address\n\nmy_new_vp = credential_schemas.CreateVPHttp(\n    vc_id=vc_id,\n    proof_type=\"SMTInclusionProof\",\n    material={\n        \"challenge\": \"0x18\",\n        \"domain\": f\"{ADDRESS_FOR_YOUR_CREDENTIAL_DOMAIN}\",\n        \"presentation_time\": int(datetime.timestamp(datetime.now()))\n    }\n)\n\nvp_id = await client.create_vp(createvphttp=my_new_vp)\n\nvp = await client.get_vp(vp_id=vp_id)\n\nresult = await client.verify_vp(body=json.dumps(vp.vp))\n</code></pre>"},{"location":"usage/#publish-a-resource","title":"Publish a resource","text":"<p>The resource service provides a use case for DIDs with VCs. To gain access to resources, represented by Bundles, an entity can use a VP. You can use the SDK to create a bundle, populate it with files, and publish it to make it visible and accessible. <pre><code>from simba_sdk.ensure.client import resource_schemas, resource_queries\nstorages = await client.get_storages(query_arguments=resource_queries.GetStoragesQuery(page=1, size=100))\n\n# whatever storage you want\nstorage = storages.items[0]\n\nmy_new_bundle = resource_schemas.CreateResourceBundleRequest(\n  name=\"mybundle\",\n  storage_name=storage.name,\n  tags=[\"test\", \"ensure\", \"sdk\"],\n)\nbundle = await client.create_bundle(createresourcebundlerequest=my_new_bundle)\n# We have an empty bundle on chain\nupload_task = await client.upload_files(uid=bundle.id, file_url=\"./my_secure_bundle_data.zip\")\n# Same as the DID, we need to wait for this task to complete before we publish\nwhile True:\n    upload_task = await client.resource_get_task(uid=bundle.id, task_id=upload_task.id)\n    if upload_task.status == resource_schemas.TaskStatus.COMPLETED:\n        break\n\n# The bundle contains your data\npublicationrequest = resource_schemas.PublicationRequest(\n    action=resource_schemas.Action.publish,\n    account=client.account.model_dump()\n)\npublish_task = await client.publish_action(uid=bundle.id, publicationrequest=publicationrequest)\nwhile True:\n    publish_task = await client.resource_get_task(uid=bundle.id, task_id=publish_task.id)\n    if publish_task.status == resource_schemas.TaskStatus.COMPLETED:\n        break\n\n# The bundle is now visible and accessible on the chain. Entities can request access to it now.\n# If we want to control access we must add access policies to be tested against Holder VCs.\nnew_policy = resource_schemas.Policy(\n    identifier=my_schema.attributes[0].hash,  # the schema we used to define our VC\n    junction=resource_schemas.Junction.AND,\n    dataType=resource_schemas.DataType.STR,\n    criteria=[\n        {\n            \"op\": resource_schemas.Op.EQ,\n            \"value\": my_schema.attributes[0].suggestedValues[0], # again, this should be whatever value you want to restrict access by\n        }\n    ]\n\n)\npolicy = await client.add_policy(uid=bundle.id, policy=new_policy)\n</code></pre></p>"},{"location":"usage/#request-access","title":"Request access","text":"<p>As the holder of a DID with VCs, you can use VPs of that VC to request access to bundles. The claims you hold within your VC will be matched against policies for that bundle. If you hold the required attributes, you can access that bundle. <pre><code>import time\nvp_data = vp.model_dump_json()\nvp_data = json.loads(vp_data)[\"vp\"]\nvp_data = json.dumps(vp_data)  # we need to do this to deserialise the VP properly\n\nresource_token = await client.request_access(resource_id=bundle.resource_id, body=vp_data)\n\ntime.sleep(10) # wait for the token to become valid\nwith open(\"./test_download.tar.gz\", \"wb\") as f: # the resource service will tarball your data for you to send over a connection\n    await client.get_access(output_stream=f, token=resource_token.value) # this function takes any writable IO stream, not just files!\n</code></pre></p>"}]}