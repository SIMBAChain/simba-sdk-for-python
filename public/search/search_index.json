{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>The Python Ensure SDK simplifies creating, managing, and using Ensure features from Python code. This is including but not limited to:</p> <ul> <li>Creating Decentralised Identity Documents (DIDs)</li> <li>Verifiable Credentials (VPs)</li> <li>Verifiable Presentations (VPs)</li> <li>Publishing Resources</li> <li>Access Control to resources using VPs</li> </ul>","tags":["developer tools"]},{"location":"#essential-overview","title":"Essential Overview","text":"<ul> <li>The Ensure SDK is how you should communicate with Ensure services wherever you run Python code.</li> <li>The minimum supported Python version is 3.8 or later.</li> <li>You must have been onboarded to a SIMBA environment that has Ensure available to use the SDKs.</li> <li>The Ensure SDK provides all method calls as <code>async</code>, providing flexibility for long-running code. (ref)</li> </ul> <p>The SDK and API is still in development. Whilst we strive for stability, please be aware that functions may change with short notice. All public-facing breaking changes will be communicated with advance notice.</p>","tags":["developer tools"]},{"location":"#non-essential-details","title":"Non-essential Details","text":"<p>The SDK is automatically generated from the OpenAPI definitions published by the services that comprise the Ensure product. It is advised that only methods defined by the <code>EnsureClient</code> class are used in your code, as everything else is subject to change without prior notice. The <code>EnsureClient</code> is designed to provide a stable interface.</p>","tags":["developer tools"]},{"location":"getting-started/","title":"Getting Started","text":"<p>from simba_sdk.core.requests.exception import EnsureExceptionfrom email.policy import default Install the latest version of the SDK via pip: <pre><code>pip install simba-sdk\n</code></pre></p> <p>The <code>simba-sdk</code> needs a configuration set up before it can be used. This is done using environment variables, so depending on your situation you may hard-code values using <code>os.environ[...]</code>, use a <code>.env</code> file, or just set environment variables at runtime.</p> <p>Here's an example of a <code>.env</code> file below. The client ID and client secret can be obtained from the members service. You will need \"User Impersonating Client Credentials\" in order to authorise the SDK to make requests on your behalf. Everything in this example file is required:</p> <pre><code>CLIENT_ID=\nCLIENT_SECRET=\nMEMBERS_URL=https://simba-sbx-members-service.blocks.simbachain.com\nCREDENTIAL_URL=https://simba-sbx-credential-service.blocks.simbachain.com\nRESOURCE_URL=https://simba-sbx-resource-service.blocks.simbachain.com\nTOKEN_URL=https://simba-sbx-members-service-validator.blocks.simbachain.com\n</code></pre>"},{"location":"getting-started/#check-your-details","title":"Check your details","text":"<p>It's a good idea validate your generated authentication credentials against the Ensure service before attempting to use it. This section assumes that you have the <code>dotenv</code> library installed, and have the required config in an <code>.env</code> file.</p> <p>Write the following code either in a script or an interactive python shell that has the Ensure SDK installed:</p> <pre><code>from dotenv import load_dotenv\n\n# load environment variables from a .env file if they are not being set in the shell\nload_dotenv(\"/path/to/config/.env\")\n\nfrom simba_sdk import EnsureClient\n\nDOMAIN = \"my_domain\"\n\n# initialise a new client\n# your auth credentials will be picked up by the settings object under the hood\nclient = EnsureClient()\n\n# The client has a few helper properties that get set the first time you authorise.\n# You can authorise manually\nawait client.authorise()\n\n# or call any of the endpoints to do so automatically.\nawait client.set_domain(DOMAIN)\n\n# any problems with authorisation will raise an exception, but just to double-check nothing's failing silently,\n# we can now check our user profile from within the client.\nprint(client.user)\n</code></pre> <p>The result should be a schema containing your profile, id, email etc. The information is obtained from the member service so it should be identical to a payload you get from the member service directly.</p>"},{"location":"getting-started/#ensure-client","title":"Ensure Client","text":"<p>SIMBA Ensure's use-cases are domain scoped. This is a namespace that contains your organisation's trust profile, storage configuration, and VP schemas.</p> <p>You also need to be able to make transactions on a blockchain (which SIMBA handles for you). If you do not already have an account setup with simba, you must use <code>EnsureClient.create_custodial_account</code> to create a custodial account.</p> <p>This code snippet runs through a \"cold start\":</p> <pre><code>from simba_sdk import EnsureClient\nfrom simba_sdk.ensure.client import credential_schemas as cs\n\nDOMAIN, BLOCKCHAIN = \"my-domain\", \"my-blockchain\"  # provided by your domain admin\n\nasync def setup() -&gt; EnsureClient:\n\n    client = EnsureClient()\n    await client.set_domain(DOMAIN)\n    try:\n        account = await client.get_default_account()\n    except:\n        account = await client.create_custodial_account(\n            cs.CreateAccountHttp(nickname=\"my-test-account\", domain=DOMAIN)\n        )\n    await client.set_account(network=BLOCKCHAIN, alias=account.alias)\n\n    return client\n\nauthenticated_client = await setup()\n</code></pre> <p>If you get an <code>EnsureClient</code> object returned successfully, then you should be ready to get started. Continue on to Usage to see how this client can be used to interact with the SIMBA Ensure product.</p>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":"<p>The ensure client uses a simple exception structure that wraps around the request exceptions raised by the service clients. This means that there should be some plain description as to what's gone wrong, but also the response itself from the API if you need to do any further digging.</p>"},{"location":"usage/","title":"Usage","text":"<p>This page covers the most common use-cases for the SIMBA Ensure product:</p> <ul> <li>Create a DID</li> <li>Issue a VC</li> <li>Publish a resource</li> <li>Create a VP</li> <li>Request access</li> </ul> <p>Here we assume that the ensure client has been setup. If you missed this step, please follow the outline in Ensure Client.</p>"},{"location":"usage/#create-a-did","title":"Create a DID","text":"<p>Decentralised Identifiers (DIDs) are an on chain way of representing a single entity (user, organisation etc.). A HOLDER DID can hold various credentials, which are issued to it by an ISSUER DID. <pre><code>import uuid\nimport time\n\nfrom simba_sdk import EnsureClient\nfrom simba_sdk.ensure.client import credential_schemas as cs\nfrom simba_sdk.ensure.client import credential_queries as cq\n\nclient: EnsureClient = ...  # assuming common setup from above\nlist_profiles_query = cq.ListTrustProfilesQuery(page=1, size=5)\ntrust_profiles_response = await client.list_trust_profiles(list_profiles_query)\ntrust_profile = trust_profiles_response.items[0]\n\nnew_issuer_did = cs.CreateDidHttp(\n    trust_profile=trust_profile.name,\n    account=cs.PubKeyAccountInfo(\n        public_key=client.account.public_key,\n        alias=client.account.alias\n    ),\n    permission=cs.DidPermission.ISSUER,\n    alias=\"my_test_issuer_did\",\n    nickname=\"My Issuer DID\",\n    public_name=cs.PublicName(f\"{client.user.profile.first_name}'s ISSUER DID\"),\n    seed = str(uuid.uuid4())\n)\n\ntask_id = await(client.create_did(createdidhttp=new_issuer_did))\n\n# This creates a task to publish the DID, here we are using a while loop to poll the\n# server until the task is complete.\ntask: cs.Task = await(client.credential_get_task(task_id))\nwhile task.status != cs.TaskStatus.COMPLETED:\n    time.sleep(1)\n    task: cs.Task = await(client.credential_get_task(task_id))\n\n# We can double-check as well\ndid: cs.DIDResponseModel = await client.get_did(did_id=task.object_id)\nprint(did)\n</code></pre></p> <p>N.B. The process is near identical for HOLDER dids, just change 'ISSUER' to 'HOLDER' in the input payload.</p>"},{"location":"usage/#issue-a-vc","title":"Issue a VC","text":"<p>One DID can issue a Verifiable Credential(VC) to another DID. This is essentially the issuer making a claim about the holder, i.e. that they hold a Bachelors Degree from the Issuer's University. VCs follow a pattern known as a schema which defines what attributes the claim is actually attributing to the Holder.</p> <pre><code>from datetime import datetime, timedelta\n\nfrom simba_sdk.ensure.client import credential_queries as cq\nfrom simba_sdk.ensure.client import credential_schemas\nfrom simba_sdk.ensure.client import EnsureClient\n\n# See \"Getting Started\" and \"Create a DID\" for details on creating these\nclient: EnsureClient = ...\nissuer_did: credential_schemas.DID = ...\nholder_did: credential_schemas.DID = ...\n\nmy_schemas =  await client.get_schema_registry()\nmy_schema = list(my_schemas.schemas.values())[0]\n\n# vc\nmy_new_vc = credential_schemas.CreateVCHttp(\n    issuer=issuer_did.did_document[\"id\"],\n    subject=holder_did.did_document[\"id\"],\n    valid_from=datetime.now() - timedelta(days=1),  # yesterday\n    valid_until=datetime.now() + timedelta(days=365),  # this time next year\n    material={\"circom_circuit\": \"SMTInclusionSingleClaim\"},  # this is how the claims will be verified against the holder on chain\n    claims={\n        # The schema comes back in the form link#schema_name. Using this information we are dynamically constructing a valid claim\n        my_schema.id[:my_schema.id.find(\"#\")]: {\n            my_schema.name: {  # this is schema_name\n                # a reliable way to make a verifiable claim.\n                my_schema.attributes[0].name: my_schema.attributes[0].suggestedValues[0],\n            }\n        }\n    },\n    tags=[\"sdk\", \"test\", \"ensure\"]\n\n)\n\n# assuming this is an asynchronous function, we can use await instead of asyncio.run()\nvc_id = await client.create_vc(createvchttp=my_new_vc)\n\nvc = await client.get_vc(vc_id=vc_id)\n\n# Verify the VC\nresult = await client.verify_vc(body=vc.model_dump_json())\nif not result.success:\n    raise Exception(\"The VC is invalid for some reason.\")\n\nawait client.accept_vc(vc_id=vc_id,query_arguments=cq.AcceptVcQuery(accept=True)) # the Holder needs to accept the credentials\n</code></pre>"},{"location":"usage/#publish-a-resource","title":"Publish a resource","text":"<p>The resource service provides a use case for DIDs with VCs. To gain access to resources, represented by Bundles, an entity can use a VP. You can use the SDK to create a bundle, populate it with files, and publish it to make it visible and accessible. <pre><code>import time\n\nfrom simba_sdk.ensure.client import resource_schemas, resource_queries\nfrom simba_sdk.ensure.client import EnsureClient\nfrom simba_sdk.ensure.client import credential_schemas as cs\n\nclient: EnsureClient = ...\n\nstorages = await client.get_storages(query_arguments=resource_queries.GetStoragesQuery(page=1, size=100))\n\n# whatever storage you want\nstorage = storages.items[0]\n\nmy_new_bundle = resource_schemas.CreateResourceBundleRequest(\n  name=\"mybundle\",\n  storage_name=storage.name,\n  tags=[\"test\", \"ensure\", \"sdk\"],\n)\nbundle = await client.create_bundle(createresourcebundlerequest=my_new_bundle)\n\nupload = await client.upload_files(uid=bundle.id, file_url=\"./my_secure_bundle_data.zip\")\n\n# Same as the DID, we need to wait for this task to complete before we publish\nupload_task = await client.resource_get_task(uid=bundle.id, task_id=upload.id)\n\nwhile upload_task.status != cs.TaskStatus.COMPLETED:\n    time.sleep(1)\n    upload_task = await client.resource_get_task(uid=bundle.id, task_id=upload_task.id)\n\n# The bundle contains your data\npublicationrequest = resource_schemas.PublicationRequest(\n    action=resource_schemas.Action.publish,\n    account=client.account.model_dump()\n)\npublish = await client.publish_action(uid=bundle.id, publicationrequest=publicationrequest)\n\npublish_task = await client.resource_get_task(uid=bundle.id, task_id=publish.id)\n\nwhile publish_task.status != cs.TaskStatus.COMPLETED:\n    time.sleep(1)\n    publish_task = await client.resource_get_task(uid=bundle.id, task_id=publish.id)\n\n# The bundle is now visible and accessible on the chain. Entities can request access to it now.\n# If we want to control access we must add access policies to be tested against Holder VCs.\nmy_schema: cs.CredentialSchema = ...\nnew_policy = resource_schemas.Policy(\n    identifier=my_schema.attributes[0].hash,  # the schema we used to define our VC\n    junction=resource_schemas.Junction.AND,\n    dataType=resource_schemas.DataType.STR,\n    criteria=[\n        {\n            \"op\": resource_schemas.Op.EQ,\n            \"value\": my_schema.attributes[0].suggestedValues[0], # this should be whatever value you want to restrict access by\n        }\n    ]\n\n)\npolicy = await client.add_policy(uid=bundle.id, policy=new_policy)\n</code></pre></p>"},{"location":"usage/#create-a-vp","title":"Create a VP","text":"<p>A Verifiable Presentation (VP) is a secure presentation of a VC. It allows entities to verify an entity holds a VC without exposing knowledge about the entity or the VC.</p> <pre><code>import json\nimport datetime\n\nfrom simba_sdk.ensure.client import credential_schemas\nfrom simba_sdk.ensure.client import EnsureClient\n\nclient: EnsureClient = ...\nmy_trust_profile: credential_schemas.TrustProfile = ...\n\nADDRESS_FOR_YOUR_CREDENTIAL_DOMAIN = my_trust_profile.config.registrar_address\n\nvc_id: str = ...  # result from client.create_vc above\n\nmy_new_vp = credential_schemas.CreateVPHttp(\n    vc_id=vc_id,\n    proof_type=\"SMTInclusionProof\",\n    material={\n        \"challenge\": \"0x18\",\n        \"domain\": f\"{ADDRESS_FOR_YOUR_CREDENTIAL_DOMAIN}\",\n        \"presentation_time\": int(datetime.timestamp(datetime.now()))\n    }\n)\n\nvp_id = await client.create_vp(createvphttp=my_new_vp)\n\nvp = await client.get_vp(vp_id=vp_id)\n\nresult = await client.verify_vp(body=json.dumps(vp.vp))\n</code></pre>"},{"location":"usage/#request-access","title":"Request access","text":"<p>As the holder of a DID with VCs, you can use VPs of that VC to request access to bundles. The claims you hold within your VC will be matched against policies for that bundle. If you holdthe required attributes, you can access that bundle.</p> <pre><code>import time\nimport json\nfrom simba_sdk.ensure.client import credential_schemas as cs\n\nvp = ... # VP from \"Create a VP\"\nbundle = ... # bundle from \"Publish a resource\"\n\nvp_data = vp.model_dump_json()\nvp_data = json.loads(vp_data)[\"vp\"]\nvp_data = json.dumps(vp_data)  # we need to do this to deserialise the VP properly\n\nresource_token = await client.request_access(resource_id=bundle.resource_id, body=vp_data)\n\ntime.sleep(10) # wait for the token to become valid\nwith open(\"./test_download.tar.gz\", \"wb\") as f: # the resource service will tarball your data for you to send over a connection\n    await client.get_access(output_stream=f, token=resource_token.value) # this function takes any writable IO stream, not just files!\n</code></pre>"}]}